/**
 * 把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s 的所有可能的值出现的概率。
 *
 * 解法一：基于通归求解，时间效率不够高。
 * 先把n个骰子分为两堆：第一堆只有一个，另一个有n- 1 个。单独的那一个有可能出现从1 到6 的点数。
 * 我们需要计算从1 到6 的每一种点数和剩下的n-1 个骰子来计算点数和。接下来把剩下的n-1个骰子还是
 * 分成两堆，第一堆只有一个， 第二堆有n-2 个。我们把上一轮那个单独骰子的点数和这一轮单独骰子的点
 * 数相加， 再和剩下的n-2 个骰子来计算点数和。分析到这里，我们不难发现这是一种递归的思路，递归结
 * 束的条件就是最后只剩下一个骰子。我们可以定义一个长度为6n-n+1 的数组， 和为s 的点数出现的次数保存到数组第s-n个元素里
 * 解法二：基于循环求解，时间性能好
 * 我们可以考虑用二维数组来存储骰子点数的每一个总数出现的次数。在一次循环中， 第一个数组中的第n
 * 个数字表示骰子和为n 出现的次数。在下一循环中，我们加上一个新的骰子，此时和为n 的骰子出现的次数
 * 应该等于上一次循环中骰子点数和为n-1 、n-2 、n-3 、n-4, n-5 与n-6 的次数的总和，所以我们把另
 * 一个数组的第n个数字设为前一个数组对应的第n-1 、n-2 、n-3 、n-4、n-5与n-6之和。
 *
 */
fun main(args: Array<String>) {

}